# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoApplication_Job.ipynb.

# %% auto 0
__all__ = ['DomoTrigger_Schedule', 'DomoTrigger', 'DomoJob', 'Watchdog_Parameter_WatchType', 'Watchdog_Parameter_EntityType',
           'Watchdog_Parameter', 'DomoJob_Watchdog']

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 3
from dataclasses import dataclass, field
from typing import List, Optional
from enum import Enum

import httpx

from nbdev.showdoc import patch_to
import domolibrary.utils.DictDot as util_dd
import domolibrary.client.DomoAuth as dmda
import datetime  as dt

from pprint import pprint

import domolibrary.routes.application as application_routes

import domolibrary.utils.convert as cc

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 5
@dataclass
class DomoTrigger_Schedule:
    schedule_text: str = None
    schedule_type: str = "scheduleTriggered"

    minute: int = None
    hour: int = None
    minute_str: str = None
    hour_str: str = None

    @classmethod
    def _from_str(cls, s_text, s_type):
        sched = cls(schedule_type=s_type, schedule_text=s_text)

        try:
            parsed_hour = s_text.split(" ")[2]
            parsed_minute = s_text.split(" ")[1]

            if "*" in parsed_hour or "/" in parsed_hour:
                sched.hour_str = parsed_hour
            else:
                sched.hour = int(float(parsed_hour))
            if "*" in parsed_minute:
                sched.minute_str = parsed_minute
            else:
                sched.minute = int(float(parsed_minute))

            return sched

        except Exception as e:
            print(f"unable to parse schedule {s_text}")
            print(e)

    def to_obj(self):
        return {"hour": int(self.hour), "minute": int(self.minute)}

    def to_json(self):
        minute = self.minute_str if self.minute_str is not None else str(self.minute)
        hour = self.hour_str if self.hour_str is not None else str(self.hour)
        return {
            "eventEntity": f"0 {minute} {hour} ? * *",
            # old value on Jan 13
            # "eventEntity": f'0 {minute} {hour} 1/1 * ? *',
            "eventType": self.schedule_type,
        }


@dataclass
class DomoTrigger:
    id: str
    job_id: str
    schedule: List[DomoTrigger_Schedule] = None

    @classmethod
    def _from_json(cls, obj):
        return cls(
            id=obj["triggerId"],
            job_id=obj["jobId"],
            schedule=DomoTrigger_Schedule._from_str(
                s_text=obj.get("eventEntity"), 
                s_type=obj.get("eventType")
            ),
        )


# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 8
@dataclass
class DomoJob:
    """
    the base class only captures attributes applicable to all jobs (i.e. does not destructure execution_payload onto the class)
    build Application / Job extensions by creating children of the DomoJob class
    """
    auth: dmda.DomoAuth = field(repr=False)

    id: str
    name: str
    user_id: str
    application_id: str
    customer_id: str
    execution_timeout: int

    execution_payload: dict
    share_state: dict
    created_dt: dt.datetime
    updated_dt: dt.datetime

    is_enabled: bool  # based on triggers

    description: str = None
    accounts: List[str] = None
    triggers: List[DomoTrigger] = field(default_factory=[])

    def _convert_API_res_to_DomoJob_base_obj(obj) -> dict:
        triggers_ls = obj.get("triggers")

        return {
            "id": obj["jobId"],
            "name": obj["jobName"],
            "user_id": obj["userId"],
            "application_id": obj["applicationId"],
            "customer_id": obj["customerId"],
            "execution_timeout": obj["executionTimeout"],
            "execution_payload": obj["executionPayload"],
            "share_state": obj["shareState"],
            "created_dt": cc.convert_epoch_millisecond_to_datetime(obj["created"]),
            "updated_dt": cc.convert_epoch_millisecond_to_datetime(obj["updated"]),
            "is_enabled": True if triggers_ls else False,
            "description": obj.get("jobDescription"),
            "accounts": obj["accounts"],
            "triggers": (
                [DomoTrigger._from_json(tg) for tg in triggers_ls]
                if triggers_ls
                else []
            ),
        }

    @classmethod
    def _from_json(
        cls,
        obj,
        auth,
    ):
        base_obj = cls._convert_API_res_to_DomoJob_base_obj(obj)

        return cls(
            auth=auth,
            **base_obj,
        )

    def _generate_to_json(self):
        return {
            "jobId": self.id,
            "jobName": self.name,
            "userId": self.user_id,
            "applicationId": self.application_id,
            "customerId": self.customer_id,
            "executionTimeout": self.execution_timeout,
            "executionPayload": self.execution_payload,
            "shareState": self.share_state,
            # created / excluded because generated metadata
            # updated / excluded because generated metadata
            "triggers": (
                [self.triggers[0].schedule.to_json()]
                if len(self.triggers) > 0
                else []
            ),
            "jobDescription": self.description,
            "executionTimeout": self.execution_timeout,
            "accounts": self.accounts,

        }

    def to_json(self):
        return self._generate_to_json()

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 9
@patch_to(DomoJob, cls_method=True)
async def _get_by_id(
    cls,
    application_id,
    job_id,
    auth: dmda.DomoAuth,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop=2,
    new_cls: DomoJob = None, # pass in a child class which has the mandatory "from_json" function
    return_raw : bool = False,
    parent_class = None
):
    """
    this function will receive the parent_class as an input_parameter (instead of relying on the actual class DomoJob)
    to call the `new_class._from_json()`

    this process will handle converting the JSON obj into 'the correct' class 
    """

    res= await application_routes.get_application_job_by_id(
        auth=auth,
        application_id=application_id,
        job_id = job_id,
        session=session,
        debug_api=debug_api,
    
        parent_class=parent_class,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res
            
    cls = new_cls or cls
    
    return cls._from_json(
        obj = res.response,
        auth = auth,
    )

@patch_to(DomoJob, cls_method= True)
async def get_by_id(
        cls,
        application_id,
        job_id,
        auth: dmda.DomoAuth,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
        debug_num_stacks_to_drop=2,
        return_raw :bool = False,
    ):
        """
        stub abstract function that each `DomoJob` will have.
        note we pass the calling functions class into classmethod _get_by_id()
        so that we can call cls._from_json() during code execution 
        """
        
        return await cls._get_by_id(
            application_id = application_id,
            job_id = job_id,
            auth = auth,
            debug_api = debug_api,
            session = session,
            debug_num_stacks_to_drop= debug_num_stacks_to_drop,
            return_raw = return_raw,
            new_cls = cls
            )        
    

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 13
@dataclass
class DomoJob_RemoteDomoStats(DomoJob):
    configured_reports: List[dict] = None
    remote_instance: str = None
    output_dataset_id: str = None
    subscriber_job_id: str = None

    @classmethod
    def _from_json(cls, obj, auth):

        return cls(
            **cls._convert_API_res_to_DomoJob_base_obj(obj),
            remote_instance=cls._get_remote_instance(
                obj["executionPayload"]["remoteInstance"]
            ),
            configured_reports=obj["executionPayload"]["policies"],
            output_dataset_id=obj["executionPayload"]["metricsDatasetId"],
            subscriber_job_id=obj["executionPayload"]["subscriberJobId"],
            auth=auth
        )

    @staticmethod
    def _get_remote_instance(remote_instance):
        return remote_instance.replace(".domo.com", "")

    @classmethod
    async def get_by_id(
        cls,
        application_id,
        job_id,
        auth: dmda.DomoAuth,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
        debug_num_stacks_to_drop=2,
        return_raw: bool = False,
    ):

        return await cls._get_by_id(
            application_id=application_id,
            job_id=job_id,
            auth=auth,
            debug_api=debug_api,
            session=session,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            return_raw=return_raw,
            new_cls=cls,
            parent_class=cls.__name__,
        )

    def to_json(self):
        execution_payload = {
            "metricsDatasetId": self.output_dataset_id,
            "policies": self.configured_reports,
            "remoteInstance": self.remote_instance,
            "subscriberJobId": self.subscriber_job_id,
        }
        return {**self._generate_to_json(), "executionPayload": execution_payload}

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 16
@patch_to(DomoJob_RemoteDomoStats, cls_method= True)
async def create(
    cls,
    auth: dmda.DomoAuth,
    trigger_schedule: DomoTrigger_Schedule,
    
    target_instance: str,
    output_dataset_id: str,
    account_id: str,
    
    report_dict: dict,
    
    execution_timeout: int = 1440,

    return_raw: bool = False,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    session: Optional[httpx.AsyncClient] = None,
):

    schedule_obj = trigger_schedule.to_json()

    body = application_routes.generate_body_remote_domostats(
        target_instance=target_instance,
        report_dict=report_dict,
        output_dataset_id=output_dataset_id,
        account_id=account_id,
        schedule_ls=[schedule_obj],
        execution_timeout=execution_timeout,
    )

    res = await application_routes.application(
        auth=auth,
        application_id=application_id,
        body=body,
        parent_class=cls.__name__,

        session=session,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

    if return_raw:
        return res

    return cls._from_json(res.response, auth = auth)

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 19
class Watchdog_Parameter_WatchType(Enum):
    ERROR_DETECTION = "error_detection"
    DATASET_INDEX_TIME = "max_indexing_time"
    LAST_UPDATED_DATA = "last_data_updated"
    ROW_COUNT_CHANGE = "row_count_variance"
    CUSTOM_QUERY = "custom_query"
    OUTLIER_EXECUTION = "execution_variance"


class Watchdog_Parameter_EntityType(Enum):
    DATAFLOW = "DATAFLOW"
    DATASET = "DATASET"


@dataclass
class Watchdog_Parameter:
    entity_ids: any
    entity_type: Watchdog_Parameter_EntityType
    watch_type: Watchdog_Parameter_WatchType

    @classmethod
    def _from_json(cls, obj):  # executionPayload

        obj_type = obj["type"].upper()
        entity_type = obj["entityType"].upper()
        entity_ids = obj["entityIds"]

        return cls(
            entity_ids=entity_ids,
            entity_type=Watchdog_Parameter_EntityType[entity_type],
            watch_type=Watchdog_Parameter_WatchType[obj_type],
        )

    def to_json(self):
        return {"entityIds": self.entity_ids,
                "entityType": self.entity_type.value,
                "type": self.watch_type.value}

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 20
@dataclass
class DomoJob_Watchdog(DomoJob):
    custom_message: str = None
    remote_instance: str = None
    logs_dataset_id: str = None

    notify_emails: List[str] = None
    notify_group_ids: List[str] = None
    notify_user_ids: List[str] = None

    watcher_parameters: Watchdog_Parameter = None
    webhooks: List[str] = None

    @classmethod
    def _from_json(cls, obj, auth):

        remote_instance = obj["executionPayload"]["domain"]

        return cls(
            **cls._convert_API_res_to_DomoJob_base_obj(obj),
            custom_message = obj['executionPayload']['customMessage'],
            remote_instance=(
                cls._get_remote_instance(remote_instance) if remote_instance else None
            ),
            logs_dataset_id=obj["executionPayload"]["metricsDatasetId"],
            watcher_parameters=Watchdog_Parameter._from_json(
                obj["executionPayload"]["watcherParameters"]
            ),
            notify_emails=obj["executionPayload"]["notifyEmailAddresses"],
            notify_group_ids=obj["executionPayload"]["notifyGroupIds"],
            notify_user_ids=obj["executionPayload"]["notifyUserIds"],
            webhooks=obj["executionPayload"]["webhooks"],
            auth=auth
        )

    @staticmethod
    def _get_remote_instance(remote_instance):
        return remote_instance.replace(".domo.com", "")

    @classmethod
    async def get_by_id(
        cls,
        application_id,
        job_id,
        auth: dmda.DomoAuth,
        debug_api: bool = False,
        session: Optional[httpx.AsyncClient] = None,
        debug_num_stacks_to_drop=2,
        return_raw: bool = False,
    ):

        return await cls._get_by_id(
            application_id=application_id,
            job_id=job_id,
            auth=auth,
            debug_api=debug_api,
            session=session,
            debug_num_stacks_to_drop=debug_num_stacks_to_drop,
            return_raw=return_raw,
            new_cls=cls,
            parent_class=cls.__name__,
        )

    def to_json(self):
        execution_payload = {
            "customMessage": self.custom_message,
            "domain": self.remote_instance,
            "metricsDatasetId": self.logs_dataset_id,
            "notifyEmailAddresses": self.notify_emails,
            "notifyGroupIds": self.notify_group_ids,
            "notifyUserIds": self.notify_user_ids,
            "watcherParameters": self.watcher_parameters.to_json(),
            "webhooks": self.webhooks,
        }
        return {**self._generate_to_json(), "executionPayload": execution_payload}

# %% ../../nbs/classes/50_DomoApplication_Job.ipynb 27
@patch_to(DomoJob)
async def execute(
    self,
    debug_api: bool = False,
    session: Optional[httpx.AsyncClient] = None,
    debug_num_stacks_to_drop = 2
):

    res = await application_routes.execute_application_job(
        auth=self.auth,
        application_id=self.application_id,
        job_id=self.id,
        debug_api=debug_api,
        session=session,
        parent_class = self.__class__.__name__,
        debug_num_stacks_to_drop = debug_num_stacks_to_drop

    )

    return res

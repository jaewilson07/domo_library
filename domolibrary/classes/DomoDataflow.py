# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/classes/50_DomoDataflow.ipynb.

# %% ../../nbs/classes/50_DomoDataflow.ipynb 2
from __future__ import annotations

from enum import Enum
from dataclasses import dataclass, field
import httpx

import datetime as dt
import domolibrary.utils.convert as ct
import domolibrary.utils.DictDot as util_dd

import domolibrary.client.DomoAuth as dmda
import domolibrary.client.DomoError as de
import domolibrary.routes.dataflow as dataflow_routes
from nbdev.showdoc import patch_to, show_doc

# %% auto 0
__all__ = ['DomoDataflow']

# %% ../../nbs/classes/50_DomoDataflow.ipynb 3
class DomoDataflow_Action_Type(Enum):
    LoadFromVault = "LoadFromVault"
    PublishToVault = "PublishToVault"
    GenerateTableAction = "GenerateTableAction"


@dataclass
class DomoDataflow_Action:
    id: str
    name: str
    depends_on : str
    type: str

    datasource_id: str  = None
    sql: str = None

    @classmethod
    def _from_json(cls, obj: dict):
        dd = obj

        if isinstance(dd, dict):
            dd = util_dd.DictDot(obj)

        tbl_name = dd.dataSource.name if dd.dataSource else None
        ds_id = dd.dataSource.guid if dd.dataSource else None

        return  cls(
            type=dd.type,
            id=dd.id,
            name=dd.name or dd.targetTableName or dd.tableName or tbl_name,
            depends_on = dd.dependsOn,
            
            datasource_id=dd.dataSourceId or ds_id,
            sql=dd.selectStatement or dd.query,
        )

@dataclass
class DomoDataflow_ActionExecuted(DomoDataflow_Action):
    begin_time : dt.datetime = None
    end_time : dt.datetime = field(init = False )
    is_success : bool = field(init=False)
    rows_process : int = field(init = False)

    @classmethod
    def _from_json(cls, obj):
        dd = obj

        if isinstance(dd, dict):
            dd = util_dd.DictDot(obj)

        base_cls = super()._from_json(obj)

        print(base_cls.__dict__, base_cls.__class__.__name__)

        cls(
            rows_processed =  dd.rowsProcessed,
            is_success = dd.wasSuccessful,
            begin_time = dd.beginTime,
            end_time = dd.endTime,

            **base_cls.__dict__,
        
        )

# %% ../../nbs/classes/50_DomoDataflow.ipynb 6
@dataclass
class DomoDataflow:
    id: str
    name: str = None
    auth: dmda.DomoAuth = field(default=None)
    owner: str = None
    description: str = None
    tags: list[str] = None
    actions: list[DomoDataflow_Action] = None
    execution_history : list[DataflowExecution_Summary] = None

# %% ../../nbs/classes/50_DomoDataflow.ipynb 7
@patch_to(DomoDataflow, cls_method=True)
async def get_from_id(
    cls: DomoDataflow,
    dataflow_id: int,
    auth: dmda.DomoAuth = None,
    return_raw: bool = False,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    res = await dataflow_routes.get_dataflow_by_id(
        auth=auth,
        dataflow_id=dataflow_id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=cls.__name__,
        session=session,
    )

    if return_raw:
        return res

    if not res.is_success:
        return None

    dd = util_dd.DictDot(res.response)
    domo_dataflow = cls(
        auth=auth,
        id=dd.id,
        name=dd.name,
        description=dd.description,
        owner=dd.owner,
        tags=dd.tags,
    )

    if dd.actions:
        domo_dataflow.actions = [
            DomoDataflow_Action._from_json(action) for action in dd.actions
        ]

    return domo_dataflow

# %% ../../nbs/classes/50_DomoDataflow.ipynb 11
@patch_to(DomoDataflow)
async def get_execution_history(
    self: DomoDataflow,
    auth: dmda.DomoAuth = None,
    maximum=100,  # maximum number of execution histories to retrieve
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
    return_raw: bool = False,
):
    """retrieves metadata about execution history.  includes details like execution status"""

    auth = auth or self.auth

    res = await dataflow_routes.get_dataflow_execution_history(
        auth=auth,
        dataflow_id=self.id,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
        parent_class=self.__class__.__name__,
        maximum=maximum,
    )

    if return_raw:
        return res

    self.execution_history = [
        DomoDataflow_ExecutionSummary._from_json(df_obj, auth) for df_obj in res.response
    ]

    return self.execution_history

# %% ../../nbs/classes/50_DomoDataflow.ipynb 14
@patch_to(DomoDataflow)
async def execute(
    self: DomoDataflow,
    auth: dmda.DomoAuth = None,
    debug_api: bool = False,
    debug_num_stacks_to_drop=2,
):
    return await dataflow_routes.execute_dataflow(
        auth=auth or self.auth,
        dataflow_id=self.id,
        parent_class=self.__class__.__name__,
        debug_api=debug_api,
        debug_num_stacks_to_drop=debug_num_stacks_to_drop,
    )

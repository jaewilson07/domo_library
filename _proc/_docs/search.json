[
  {
    "objectID": "classes/domodataset.html",
    "href": "classes/domodataset.html",
    "title": "Dataset",
    "section": "",
    "text": "The DomoDataset_Schema class will be a subclass of DomoDataset. It will handle all of the methods for interacting with schemas.\n\nIn execution, the schema is separate from the data that gets uploaded from Vault to Adrenaline. The domo schema defines how the data is loaded into Vault.\nBe cognizant to match dataset uploads with schema definitions. If the schema and uploaded data types do not match, the dataset may be unable to index in Adrenaline (and therefore not update).\n\n\nsource\n\n\n\n DomoDataset_Schema (dataset:<built-infunctionany>=None,\n                     columns:List[__main__.DomoDataset_Schema_Column]=<fac\n                     tory>)\n\nclass for interacting with dataset schemas\n\nsource\n\n\n\n\n DomoDataset_Schema_Column (name:str, id:str, type:str)\n\n\nsource\n\n\n\n\n DatasetSchema_DatasetNotProvidedError ()\n\nreturn if DatasetSchema request does not have a dataset id\n\nsource\n\n\n\n\n DatasetSchema_AuthNotProvidedError (dataset_id)\n\nreturn if DatasetSchema request cannot access an auth object\n\nsource\n\n\n\n\n DomoDataset_Schema.get\n                         (auth:Optional[domolibrary.client.DomoAuth.DomoAu\n                         th]=None, dataset_id:str=None,\n                         debug_api:bool=False, return_raw_res:bool=False)\n\nmethod that retrieves schema for a dataset\n\n\nStandard implementation will be to access the DomoDataset_Schema class as the DomoDataset.schema property\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_schema = DomoDataset_Schema()\n\nawait ds_schema.get(auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"])\n\n[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'),\n DomoDataset_Schema_Column(name='url', id='url', type='STRING'),\n DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'),\n DomoDataset_Schema_Column(name='article', id='article', type='STRING'),\n DomoDataset_Schema_Column(name='views', id='views', type='LONG'),\n DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'),\n DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')]\n\n\n\nsource\n\n\n\n\n\n DomoDataset_Tags (dataset:<built-infunctionany>=None,\n                   tag_ls:List[str]=<factory>)\n\nclass for interacting with dataset tags\n\nsource\n\n\n\n\n DatasetTags_SetTagsError (dataset_id, domo_instance)\n\nreturn if DatasetTags request is not successfull\n\nsource\n\n\n\n\n DatasetTags_AuthNotProvidedError (id)\n\nreturn if DatasetTags request cannot access an auth object\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_tag = DomoDataset_Tags()\nawait ds_tag.get(auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"])\n\n['2023', 'developer_documentation', 'Jan-17-2023 21:17', 'hackercore']\n\n\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday = dt.datetime.now().strftime(\"%b-%d-%Y %H:%M\")\nds_tag = DomoDataset_Tags()\nawait ds_tag.set(\n    auth=token_auth,\n    dataset_id=os.environ[\"DOJO_DATASET_ID\"],\n    tag_ls=[\"developer_documentation\", \"hackercore\", today],\n)\n\n['developer_documentation', 'hackercore', 'Jan-17-2023 21:18']\n\n\n\nsource\n\n\n\n\n DomoDataset_Tags.add (add_tag_ls:[<class'str'>], dataset_id:str=None,\n                       auth:Optional[domolibrary.client.DomoAuth.DomoAuth]\n                       =None, debug_api:bool=False, session:Optional[aioht\n                       tp.client.ClientSession]=None)\n\nappends tags to the list of existing dataset_tags\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday_year = dt.datetime.today().strftime(\"%Y\")\nds_tag = DomoDataset_Tags()\nawait ds_tag.add(\n    auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"], add_tag_ls=[today_year]\n)\n\n['2023', 'developer_documentation', 'hackercore', 'Jan-17-2023 21:18']\n\n\n\nsource\n\n\n\n\n DomoDataset_Tags.remove (remove_tag_ls:[<class'str'>],\n                          dataset_id:str=None, auth:domolibrary.client.Dom\n                          oAuth.DomoFullAuth=None, debug_api:bool=False, s\n                          ession:Optional[aiohttp.client.ClientSession]=No\n                          ne)\n\nremoves tags from the existing list of dataset_tags\n\nimport os\nimport datetime as dt\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\ntoday_year = dt.datetime.today().strftime(\"%Y\")\n\nds_tag = DomoDataset_Tags()\n\nawait ds_tag.remove(\n    auth=token_auth, dataset_id=os.environ[\"DOJO_DATASET_ID\"], remove_tag_ls=[ today_year])\n\n['developer_documentation', 'hackercore', 'Jan-17-2023 21:18']"
  },
  {
    "objectID": "classes/domoactivitylog.html",
    "href": "classes/domoactivitylog.html",
    "title": "Activity Log",
    "section": "",
    "text": "class ActivityLog_ObjectType(Enum):\n    \"\"\"enumerates valid object types to pass to activity log api\"\"\"\n\n    ACCESS_TOKEN = \"ACCESS_TOKEN\"\n    ACCOUNT = \"ACCOUNT\"\n    ACTIVITY_LOG = \"ACTIVITY_LOG\"\n    ALERT = \"ALERT\"\n    APP = \"APP\"\n    APPDB_COLLECTION = \"MAGNUM_COLLECTION\"\n    APPDB_DATASTORE = \"MAGNUM_DATASTORE\"\n    AUTHORITY = \"AUTHORITY\"\n    BEAST_MODE_FORMULA = \"BEAST_MODE_FORMULA\"\n    BUZZ_CHANNEL = \"CHANNEL\"\n    BUZZ_GROUP_CHAT = \"GROUP_CHAT\"\n    BUZZ_THREAD = \"HUDDLE\"\n    CARD = \"CARD\"\n    CHART_COLOR_PALETTE = \"CHART_COLOR_PALETTE\"\n    COLLECTION = \"COLLECTION\"\n    CUSTOMER = \"CUSTOMER\"\n    CUSTOMER_STATE = \"CUSTOMER_STATE\"\n    CUSTOMER_TIER = \"CUSTOMER_TIER\"\n    DATA_SCIENCE_NOTEBOOK = \"DATA_SCIENCE_NOTEBOOK\"\n    DATAFLOW = \"DATAFLOW_TYPE\"\n    DATASET = \"DATA_SOURCE\"\n    DATASOURCE = \"DATASOURCE\"\n    DEPLOYMENT = \"DEPLOYMENT\"\n    DRILL_VIEW = \"DRILL_VIEW\"\n    EASY_INVITE_LINK = \"EASY_INVITE_LINK\"\n    ENABLED = \"ENABLED\"\n    FILE = \"FILE\"\n    FILE_VERSION = \"FILE_REVISION\"\n    GROUP = \"GROUP\"\n    LICENSE_PAGE = \"LICENSE_PAGE\"\n    LOGIN_SETTINGS = \"LOGIN_SETTINGS\"\n    NAME = \"NAME\"\n    PDP_FILTER = \"ADC_FILTER\"\n    PDP_POLICY = \"ADC_POLICY\"\n    PAGE = \"PAGE\"\n    PAGE_ANALYZER = \"PAGE_ANALYZER\"\n    PAGE_COLLECTION = \"PAGE_COLLECTION\"\n    PROJECT = \"PROJECT\"\n    PROJECT_LIST = \"PROJECT_LIST\"\n    PROJECT_TASK = \"PROJECT_TASK\"\n    PROJECT_TASK_ATTACHMENT = \"PROJECT_TASK_ATTACHMENT\"\n    PROJECT_TASK_OWNER = \"PROJECT_TASK_OWNER\"\n    PROXIER_EMAIL = \"PROXIER_EMAIL\"\n    PUBLIC_EMBED_URL = \"PUBLIC_URL\"\n    PUBLICATION = \"PUBLICATION\"\n    REPOSITORY = \"REPOSITORY\"\n    REPOSITORY_AUTHORIZATION = \"REPOSITORY_AUTHORIZATION\"\n    ROLE = \"ROLE\"\n    SEGMENT = \"SEGMENT\"\n    SSO_PAGE = \"SSO_PAGE\"\n    SUBSCRIBER = \"PROXY_USER\"\n    USER = \"USER\"\n    USER_STATE = \"USER_STATE\"\n    VARIABLE = \"VARIABLE\"\n    VARIABLE_CONTROL = \"VARIABLE_CONTROL\"\n    NOTEBOOK_VIEW = \"CONTAINER_VIEW\"\n    VIEW = \"VIEW\"\n    VIRTUAL_USER = \"VIRTUAL_USER\"\n    WORKBENCH_AGENT = \"Workbench_AGENT\"\n    WORKBENCH_JOB = \"Workbench_JOB\"\n    WORKBENCH_SCHEDULE = \"Workbench_SCHEDULE\"\n\n\nsource\n\nActivityLog_ObjectType\n\n ActivityLog_ObjectType (value, names=None, module=None, qualname=None,\n                         type=None, start=1)\n\nenumerates valid object types to pass to activity log api\nTo get an updated list of objectTypes run the get_activity_log_object_types function.\nNote: in the ActivityLog_ObjectType enum, some of the entries have been renamed for clarity.\n\nsource\n\n\nDomoActivityLog\n\n DomoActivityLog ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(domo_instance='domo-dojo',\n                                    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"])\n\nal_res = await DomoActivityLog.get_activity_log(\n    auth = token_auth,\n    start_time = start_datetime,\n    end_time = end_datetime,\n    object_type = ActivityLog_ObjectType.ACTIVITY_LOG,\n    maximum =5)\n\npd.DataFrame(al_res)\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n      time_dt\n      date\n    \n  \n  \n    \n      0\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990066301\n      Updated DataSet\n      None\n      2023-01-17 21:14:26.301\n      2023-01-17\n    \n    \n      1\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990063200\n      Updated DataSet\n      None\n      2023-01-17 21:14:23.200\n      2023-01-17\n    \n    \n      2\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990060202\n      Updated DataSet\n      None\n      2023-01-17 21:14:20.202\n      2023-01-17\n    \n    \n      3\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990027475\n      Updated DataSet\n      None\n      2023-01-17 21:13:47.475\n      2023-01-17\n    \n    \n      4\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990024604\n      Updated DataSet\n      None\n      2023-01-17 21:13:44.604\n      2023-01-17"
  },
  {
    "objectID": "client/get_data.html",
    "href": "client/get_data.html",
    "title": "get_data",
    "section": "",
    "text": "source\n\nget_data\n\n get_data (url:str, method:str, auth:domolibrary.client.DomoAuth.DomoAuth,\n           content_type:Optional[dict]=None, headers:Optional[dict]=None,\n           session:Optional[aiohttp.client.ClientSession]=None,\n           body:Union[dict,str,NoneType]=None, params:Optional[dict]=None,\n           debug_api:bool=False)\n\nasync wrapper for asyncio requests\n\nsample implementation of get_data\nDuring execution get_data() will attempt to retrieve exchange credentials for an auth token using the dmda.DomoFullAuth.get_auth_token() method.\nThen the appropriate headers will be passed to the request.\n\nimport os\n\nfull_auth = dmda.DomoFullAuth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"jae@onyxreporting.com\",\n    domo_password=os.environ[\"DOJO_PASSWORD\"]\n)\n\nurl = \"https://domo-dojo.domo.com/api/content/v2/users/me\"\n\ntry:\n    res = await get_data(url=url, method=\"get\", auth=full_auth)\n    print(res)\n\nexcept Exception as e:\n    print(e)\n\nResponseGetData(status=401, response='Unauthorized', is_success=False)\n\n\n\nsource\n\n\n\nLooperError\n\n LooperError (loop_stage:str, message)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nlooper\n\n looper (auth:domolibrary.client.DomoAuth.DomoAuth,\n         session:aiohttp.client.ClientSession, url, offset_params,\n         arr_fn:<built-infunctioncallable>, loop_until_end:bool=False,\n         method='POST', body:dict=None, fixed_params:dict=None,\n         offset_params_in_body:bool=False, body_fn=None, limit=1000,\n         skip=0, maximum=2000, debug_api:bool=False,\n         debug_loop:bool=False)"
  },
  {
    "objectID": "client/logger.html#logger-traceback-methods",
    "href": "client/logger.html#logger-traceback-methods",
    "title": "Logger",
    "section": "Logger traceback methods",
    "text": "Logger traceback methods\nPrivate methods for adding traceback details to logs\n\n\nLogger._get_traceback\n\n Logger._get_traceback (root_module:str='<module>', num_stacks_to_drop=0)\n\nmethod that retrieves traceback\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nroot_module\nstr\n\n\n\n\nnum_stacks_to_drop\nint\n0\ndrop entries from the top of stack to exclude the functions that retrieve the traceback\n\n\nReturns\n[<class ‘traceback.FrameSummary’>]\n\n\n\n\n\n\n\n\nTracebackDetails\n\n TracebackDetails (function_name:str, file_name:str, function_trail:str)\n\nresult of _get_traceback_details function\n\n\n\nLogger._get_traceback_details\n\n Logger._get_traceback_details\n                                (traceback_list:[<class'traceback.FrameSum\n                                mary'>])\n\nreturns TracebackDetails, for the entry at the top of the stack\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntraceback_list\n[<class ‘traceback.FrameSummary’>]\n\n\n\nReturns\nTracebackDetails\ndescriptive summary from the top of the traceback\n\n\n\n\n\nsample implementations of stack tracing methods\n\nimport pandas as pd\n\n\ndef custom_write_logs_fn(logs):\n    print(\"printing logs\")\n    return pd.DataFrame(logs)\n\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_trace():\n    return logger._get_traceback(num_stacks_to_drop=1)\n\n\n# print traceback for the test_trace function\n# notice with num_stacks_to_drop = 1 we exclude the _get_traceback function from the traceback\ntb = test_trace()\nprint({\"traceback function\": [line[2] for line in tb]})\n\n\ndef test_get_details():\n    tb = logger._get_traceback(num_stacks_to_drop=1)\n    return logger._get_traceback_details(tb)\n\n\n# print traceback details for test_get_details function\ntest_get_details().__dict__\n\n{'traceback function': ['<module>', 'test_trace']}\n\n\n{'function_name': 'test_get_details',\n 'file_name': '<ipython-input-1-67d667b8d98b>',\n 'function_trail': '<module> -> test_get_details'}\n\n\n\n# assert that the result of test_trace is of type FrameSummary\ntest_eq(type(tb[0]), traceback.FrameSummary)"
  },
  {
    "objectID": "client/logger.html#logger-logging-methods",
    "href": "client/logger.html#logger-logging-methods",
    "title": "Logger",
    "section": "Logger logging methods",
    "text": "Logger logging methods\n\n\nLogger.log_warning\n\n Logger.log_warning (message, entity_id:Optional[str]=None,\n                     domo_instance:Optional[str]=None, debug_log=False,\n                     num_stacks_to_drop=3)\n\nlog a warning message\n\n\n\nLogger.log_error\n\n Logger.log_error (message, entity_id:Optional[str]=None,\n                   domo_instance:Optional[str]=None, debug_log=False,\n                   num_stacks_to_drop=3)\n\nlog an error message\n\n\n\nLogger.log_info\n\n Logger.log_info (message, entity_id:Optional[str]=None,\n                  domo_instance:Optional[str]=None, debug_log=False,\n                  num_stacks_to_drop=3)\n\nlog an informational message\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_log():\n    return logger.log_info(\"test the error returns type Info\", debug_log=False)\n\n\ntest_log()\n\nNameError: name 'Logger' is not defined"
  },
  {
    "objectID": "client/logger.html#outputting-logs",
    "href": "client/logger.html#outputting-logs",
    "title": "Logger",
    "section": "Outputting Logs",
    "text": "Outputting Logs\nDuring Logger instantiation, users can pass a function, output_fn which will be called with the Logger.output_log method\n\n\nLogger.output_log\n\n Logger.output_log ()\n\ncalls the user defined output function\n\nSample implementation with a custom write_logs method\n\nimport pandas as pd\n\ndef custom_write_logs_fn(logs):\n    print(\"printing logs\")\n    return pd.DataFrame(logs)\n\n\nlogger = Logger(app_name=\"test\", output_fn=custom_write_logs_fn)\n\n\ndef test_error():\n    try:\n        if 1 == 1:\n            raise Exception(\"random error\")\n\n    except Exception as e:\n        logger.log_error(e)\n\n\ndef double_test():\n    test_error()\n\n\n# record first error\ntest_error()\n\n# records second error nested inside double_test()\ndouble_test()\n\nlogger.output_log()\n\nprinting logs\n\n\n\n\n\n\n  \n    \n      \n      date_time\n      application\n      log_type\n      log_message\n      breadcrumb\n      domo_instance\n      entity_id\n      function_name\n      file_name\n      function_trail\n    \n  \n  \n    \n      0\n      2023-01-17 21:16:07.613042\n      test\n      Error\n      random error\n      \n      None\n      None\n      test_error\n      <ipython-input-1-235f75018073>\n      <module> -> test_error\n    \n    \n      1\n      2023-01-17 21:16:07.613240\n      test\n      Error\n      random error\n      \n      None\n      None\n      test_error\n      <ipython-input-1-235f75018073>\n      <module> -> double_test -> test_error"
  },
  {
    "objectID": "client/responsegetdata.html",
    "href": "client/responsegetdata.html",
    "title": "ResponseGetData",
    "section": "",
    "text": "source\n\nResponseGetData\n\n ResponseGetData (status:int, response:<built-infunctionany>,\n                  is_success:bool, auth:dict=None)\n\npreferred response class for all API Requests\n\nrgd = ResponseGetData(status=200, response=\"test\", is_success=True)\nrgd\n\nResponseGetData(status=200, response='test', is_success=True)\n\n\n\n\nClassmethods from Response objects by library\nThis code base supports two API request libraries, requests.request (synchronous) and aiohttp.ClientRequest (asynchronous) this can be extended as new libraries emerge with different performance characteristics.\n\nsource\n\nResponseGetData._from_requests_response\n\n ResponseGetData._from_requests_response (res:requests.models.Response)\n\nreturns ResponseGetData\n\n\n\n\nType\nDetails\n\n\n\n\nres\nResponse\nrequests response object\n\n\nReturns\nResponseGetData\n\n\n\n\n\n# test _from_requests_response returns ResponseGetData class\nimport os\nimport requests\n\nurl = f\"https://domo-dojo.domo.com/api/content/v2/authentication\"\n\ntokenHeaders = {\"Content-Type\": \"application/json\"}\n\nbody = {\n    \"method\": \"password\",\n    \"emailAddress\": \"jae@onyxreporting.com\",\n    \"password\": os.environ[\"DOJO_PASSWORD\"],\n}\n\nres = requests.request(method=\"POST\", url=url, json=body, headers=tokenHeaders)\n\nprint(res.status_code)\n\ntest_res = ResponseGetData._from_requests_response(res)\ntest_res.__dict__.keys()\n\n200\n\n\ndict_keys(['status', 'response', 'is_success', 'auth'])\n\n\n\nsource\n\n\nResponseGetData._from_aiohttp_response\n\n ResponseGetData._from_aiohttp_response\n                                         (res:aiohttp.client_reqrep.Client\n                                         Response, auth:Optional[<built-\n                                         infunctionany>]=None)\n\nasync method returns ResponseGetData\n\n# test _from_aiohttp_response returns ResponseGetData class\n\nimport os\nimport requests\n\n\nurl = f\"https://domo-dojo.domo.com/api/content/v2/authentication\"\n\nbody = {\n    \"method\": \"password\",\n    \"emailAddress\": \"jae@onyxreporting.com\",\n    \"password\": os.environ[\"DOJO_PASSWORD\"],\n}\n\nsession = aiohttp.ClientSession()\nres = await session.post(url=url, json=body)\nawait session.close()\n\nprint(res.status)\n\ntest_res = await ResponseGetData._from_aiohttp_response(res)\ntest_res.__dict__.keys()\n\n200\n\n\ndict_keys(['status', 'response', 'is_success', 'auth'])"
  },
  {
    "objectID": "client/domoauth.html",
    "href": "client/domoauth.html",
    "title": "DomoAuth",
    "section": "",
    "text": "Stand alone functions for users who prefer a functional programming approach\n\n\n\nsource\n\n\n\n get_full_auth (domo_instance:str, domo_username:str, domo_password:str,\n                session:Optional[aiohttp.client.ClientSession]=None,\n                debug_api:bool=False)\n\nuses username and password authentication to retrieve a full_auth access token\n\n\n\nimport os\n\nres = await get_full_auth(\n    domo_instance=\"domo-dojo\",\n    domo_username=\"test@test.com\",\n    domo_password=\"fake password\",\n)\nres\n\nResponseGetData(status=200, response={'success': False, 'reason': 'INVALID_CREDENTIALS'}, is_success=True)\n\n\n\nres = await get_full_auth(domo_instance=\"test\",\n                          domo_username=\"fake@test.com\", \n                          domo_password=\"fake password\")\nres\n\nResponseGetData(status=403, response='Forbidden', is_success=False)\n\n\nThe 403 response is expected because test.domo.com presumeably does not exist or access if forbidden.\n\n\n\n\n\n\nsource\n\n\n\n get_developer_auth (domo_client_id:str, domo_client_secret:str,\n                     session:Optional[aiohttp.client.ClientSession]=None,\n                     debug_api:bool=False)\n\nonly use for authenticating against apis documented under developer.domo.com\n\n\nThe 401 response is expected because we are using invalid credentials\n\nawait get_developer_auth(domo_client_id=\"test_id\",\n                         domo_client_secret=\"test_secret\"\n                         )\n\nResponseGetData(status=401, response='Unauthorized', is_success=False)\n\n\n\n\n\n\n\nThis access_token based authentication assumes the user has been provided a valid access token from Domo > Admin > Authentication > Access Token so authentication routes are actually not required.\nPer the Domo JavaCLI implementation, users can test the validity of the access_token agains the ‘me’ API\n!! Note about the Me API !! It appears that access_token authentication will direct the\n\nsource\n\n\n\n test_access_token (domo_access_token:str, domo_instance:str,\n                    session:Optional[aiohttp.client.ClientSession]=None,\n                    debug_api:bool=False)\n\nwill attempt to validate against the ‘me’ API. This is the same authentication test the Domo Java CLI uses.\n\n\n\nimport os\n\nawait test_access_token(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN']\n)\n\nResponseGetData(status=200, response={'id': 1893952720, 'invitorUserId': 587894148, 'displayName': 'Jae Wilson', 'userName': 'jae@onyxreporting.com', 'emailAddress': 'jae@onyxreporting.com', 'avatarKey': 'c605f478-0cd2-4451-9fd4-d82090b71e66', 'accepted': True, 'userType': 'USER', 'modified': 1651692505000, 'created': 1588960518, 'role': 'Admin', 'rights': 63, 'active': True, 'pending': False, 'systemUser': False, 'anonymous': False}, is_success=True)"
  },
  {
    "objectID": "client/domoauth.html#domoauth-error-classes",
    "href": "client/domoauth.html#domoauth-error-classes",
    "title": "DomoAuth",
    "section": "DomoAuth Error Classes",
    "text": "DomoAuth Error Classes\n\nsource\n\nInvalidInstanceError\n\n InvalidInstanceError (status:Optional[int]=None, message='invalid\n                       instance', domo_instance:Optional[str]=None)\n\nreturn if invalid domo_instance sent to API\n\nsource\n\n\nInvalidCredentialsError\n\n InvalidCredentialsError (status:Optional[int]=None, message='invalid\n                          credentials', domo_instance:Optional[str]=None)\n\nreturn invalid credentials sent to API\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstatus\nOptional\nNone\nAPI request status\n\n\nmessage\nstr\ninvalid credentials\n\n\n\ndomo_instance\nOptional\nNone"
  },
  {
    "objectID": "client/domoauth.html#domofullauth",
    "href": "client/domoauth.html#domofullauth",
    "title": "DomoAuth",
    "section": "DomoFullAuth",
    "text": "DomoFullAuth\n\nsource\n\nDomoFullAuth\n\n DomoFullAuth (domo_instance:str, domo_username:str, domo_password:str,\n               token:Optional[str]=None, token_name:Optional[str]=None,\n               user_id:Optional[str]=None, auth_header:dict=<factory>,\n               url_manual_login:Optional[str]=None)\n\nuse for full authentication token\n\nsample implementations of DomoFullAuth\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"domo-dojo\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    res = await full_auth.get_auth_token()\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 200 - INVALID_CREDENTIALS at domo-dojo\n\n\n\ntry:\n    full_auth = DomoFullAuth(domo_instance=\"test\",\n                             domo_username=\"test12@domo.com\",\n                             domo_password=\"test1234\")\n    await full_auth.get_auth_token()\nexcept InvalidInstanceError as e:\n    print(e)\n\nStatus 403 - INVALID INSTANCE at test"
  },
  {
    "objectID": "client/domoauth.html#domotokenauth",
    "href": "client/domoauth.html#domotokenauth",
    "title": "DomoAuth",
    "section": "DomoTokenAuth",
    "text": "DomoTokenAuth\n\nsource\n\nDomoTokenAuth\n\n DomoTokenAuth (domo_instance:str, domo_access_token:str,\n                token:Optional[str]=None, token_name:Optional[str]=None,\n                user_id:Optional[str]=None, auth_header:dict=<factory>,\n                url_manual_login:Optional[str]=None)\n\nuse for access_token authentication. Tokens are generated in domo > admin > access token Necessary in cases where direct sign on is not permitted\n\nSample implementation of DomoTokenAuth\n\ntry:\n    domo_auth = DomoTokenAuth(domo_instance=\"domo-dojo\",\n                              domo_access_token='fake password')\n    token = await domo_auth.get_auth_token()\n    print(domo_auth)\n\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized at domo-dojo"
  },
  {
    "objectID": "client/domoauth.html#domodeveloperauth",
    "href": "client/domoauth.html#domodeveloperauth",
    "title": "DomoAuth",
    "section": "DomoDeveloperAuth",
    "text": "DomoDeveloperAuth\n\nsource\n\nDomoDeveloperAuth\n\n DomoDeveloperAuth (domo_client_id:str, domo_client_secret:str)\n\nuse for full authentication token\n\nSample implementations of DomoDeveloperAuth\n\ndomo_client_id = \"test_client\"\ndomo_client_secret = \"test_secret\"\n\ntry:\n    domo_auth = DomoDeveloperAuth(domo_client_id, domo_client_secret)\n    await domo_auth.get_auth_token()\nexcept InvalidCredentialsError as e:\n    print(e)\n\nStatus 401 - Unauthorized"
  },
  {
    "objectID": "routes/dataset.html",
    "href": "routes/dataset.html",
    "title": "Dataset Routes",
    "section": "",
    "text": "source\n\n\n\n DatasetNotFoundError (dataset_id, domo_instance)\n\nCommon base class for all non-exit exceptions.\n\nsource\n\n\n\n\n query_dataset_private (auth:domolibrary.client.DomoAuth.DomoAuth,\n                        dataset_id:str, sql:str, session:Optional[aiohttp.\n                        client.ClientSession]=None,\n                        loop_until_end:bool=False, limit=100, skip=0,\n                        maximum=100, debug_api:bool=False,\n                        debug_loop:bool=False)\n\nexecute SQL queries against private APIs, requires DomoFullAuth or DomoTokenAuth\n\nsource\n\n\n\n\n query_dataset_public\n                       (dev_auth:domolibrary.client.DomoAuth.DomoDeveloper\n                       Auth, dataset_id:str, sql:str,\n                       session:aiohttp.client.ClientSession,\n                       debug_api:bool=False)\n\nquery for hitting public apis, requires client_id and secret authentication\n\nsource\n\n\n\n\n QueryRequestError (dataset_id, domo_instance, sql)\n\nCommon base class for all non-exit exceptions.\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\",\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nsql = f\"SELECT * FROM TABLE\"\n\nds_res = await query_dataset_private(dataset_id=os.environ['DOJO_DATASET_ID'],\n                                     auth=token_auth,\n                                     sql=sql,\n                                     skip=42,\n                                     maximum=5,\n                                     loop_until_end=False)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      objectID\n      url\n      Title\n      article\n      views\n      created_dt\n      published_dt\n    \n  \n  \n    \n      0\n      000004790\n      https://domo-support.domo.com/s/article/360046...\n      Starting, Stopping, and Restarting the Workben...\n      Important:  Support for Workbench 4 ended on ...\n      39\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      1\n      000004796\n      https://domo-support.domo.com/s/article/360047...\n      Understanding the Workbench 4 User Interface\n      Important:  Support for Workbench 4 ended on ...\n      56\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      2\n      000004773\n      https://domo-support.domo.com/s/article/360046...\n      Using the External Process File Provider in Wo...\n      Important:  Support for Workbench 4 ended on ...\n      20\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00\n    \n    \n      3\n      000004798\n      https://domo-support.domo.com/s/article/360046...\n      Workbench 4 FAQs\n      Important:  Support for Workbench 4 ended on ...\n      48\n      2022-10-24T22:30:00\n      2022-10-24T22:40:00\n    \n    \n      4\n      000004800\n      https://domo-support.domo.com/s/article/360047...\n      Workbench 4 Overview\n      Important:  Support for Workbench 4 ended on ...\n      40\n      2022-10-24T22:30:00\n      2022-10-24T22:41:00"
  },
  {
    "objectID": "routes/dataset.html#dataset-properties",
    "href": "routes/dataset.html#dataset-properties",
    "title": "Dataset Routes",
    "section": "Dataset Properties",
    "text": "Dataset Properties\n\nsource\n\nget_dataset_by_id\n\n get_dataset_by_id (dataset_id:str,\n                    auth:Optional[domolibrary.client.DomoAuth.DomoAuth]=No\n                    ne, debug_api:bool=False,\n                    session:Optional[aiohttp.client.ClientSession]=None)\n\nretrieve dataset metadata\n\nimport os\nimport pandas as pd\n\ntry:\n    token_auth = dmda.DomoTokenAuth(\n        domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n    )\n\n    await get_dataset_by_id(dataset_id=123, auth=token_auth)\n\nexcept DatasetNotFoundError as e:\n    print(e)\n\ndataset - 123 not found in domo-dojo\n\n\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_res = await get_dataset_by_id(dataset_id=os.environ['DOJO_DATASET_ID'], auth=token_auth)\npd.DataFrame([ds_res.response])\n\n\n\n\n\n  \n    \n      \n      id\n      displayType\n      dataProviderType\n      type\n      name\n      owner\n      status\n      created\n      lastTouched\n      lastUpdated\n      rowCount\n      columnCount\n      cardInfo\n      properties\n      state\n      validConfiguration\n      validAccount\n      streamId\n      transportType\n      adc\n      adcExternal\n      cloudId\n      cloudName\n      permissions\n      hidden\n      tags\n      scheduleActive\n      cryoStatus\n    \n  \n  \n    \n      0\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      domo-jupyterdata\n      domo-jupyterdata\n      Jupyter\n      domo_kbs\n      {'id': '1893952720', 'name': 'Jae Wilson', 'ty...\n      SUCCESS\n      1668379680000\n      1668385822000\n      1668385822045\n      1185\n      7\n      {'cardCount': 0, 'cardViewCount': 0}\n      {'formulas': {'formulas': {}}}\n      SUCCESS\n      True\n      True\n      825\n      API\n      False\n      False\n      domo\n      Domo\n      READ_WRITE_DELETE_SHARE_ADMIN\n      False\n      [\"developer_documentation\",\"hackercore\",\"Jan-1...\n      True\n      ADRENALINE\n    \n  \n\n\n\n\n\nsource\n\n\nget_schema\n\n get_schema (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n             debug_api:bool=False)\n\nretrieve the schema for a dataset\n\nsample implementation of get_schema\n\nimport os\nimport pandas as pd\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_instance=\"domo-dojo\", domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"]\n)\n\nds_res = await get_schema(dataset_id=os.environ['DOJO_DATASET_ID'], auth=token_auth)\npd.DataFrame(ds_res.response)\n\n\n\n\n\n  \n    \n      \n      name\n      tables\n      dataSourceId\n      url\n      queryEndpoint\n      progressEndpoint\n      indexEndpoint\n      deleteEndpoint\n      versionId\n    \n  \n  \n    \n      0\n      domo_kbs\n      {'columns': [{'name': 'objectID', 'id': 'objec...\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      /schemas/853832B128D75BCE\n      /query/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /index/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /index/mmmm-0012-0200/04c1574e-c8be-4721-9846-...\n      /delete/mmmm-0012-0200/04c1574e-c8be-4721-9846...\n      3\n    \n  \n\n\n\n\n\n# retrieve schema from response\npd.DataFrame(ds_res.response.get(\"tables\")[0].get(\"columns\"))\n\n\nsource\n\n\n\nset_dataset_tags\n\n set_dataset_tags (auth:domolibrary.client.DomoAuth.DomoFullAuth,\n                   tag_ls:[<class'str'>], dataset_id:str,\n                   debug_api:bool=False,\n                   session:Optional[aiohttp.client.ClientSession]=None)\n\nREPLACE tags on this dataset with a new list\n\nimport os\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\ntag_ls = ['hackercore', 'developer_documentation']\n\nawait set_dataset_tags(auth=token_auth,\n                       tag_ls=tag_ls,\n                       dataset_id=os.environ['DOJO_DATASET_ID'])\n\nResponseGetData(status=200, response='Dataset 04c1574e-c8be-4721-9846-c6ffa491144b tags updated to [hackercore, developer_documentation]', is_success=True)"
  },
  {
    "objectID": "routes/dataset.html#upload-data",
    "href": "routes/dataset.html#upload-data",
    "title": "Dataset Routes",
    "section": "Upload Data",
    "text": "Upload Data\n\noverview\nIn the URL, parts refers to the multi-part API and is unrelated to the partitions concept. The multi-part API was designed to allow sending multiple streams of Data into a data_version simultaneously.\nIn stage 1, the values passed in the Body will be superseded by values in the COMMIT (stage 3), so best practices is to not populate values here.\nThe response includes an uploadId, which must be stored and passed to the URL of the subsequent upload request (stages 2 and 3).\n\n\nurl params\nThe dataTag parameter allows users to UPDATE or REPLACE a datatag (partition)\nNOTE: restateDataTag is largely deprecated // exists for backward compatibility\n\n\nbody params\nThe appendId parameter accepts “latest” or “None”\nlatest will APPEND the data version to the dataset\n\nsource\n\n\nUploadDataError\n\n UploadDataError (stage_num:int, dataset_id:str, domo_instance:str)\n\nraise if unable to upload data to Domo\n\nsource\n\n\nupload_dataset_stage_1\n\n upload_dataset_stage_1 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         dataset_id:str, partition_tag:str=None, session:O\n                         ptional[aiohttp.client.ClientSession]=None,\n                         debug_api:bool=False)\n\npreps dataset for upload by creating an upload_id (upload session key) pass to stage 2 as a parameter\n\nsource\n\n\nupload_dataset_stage_2_file\n\n upload_dataset_stage_2_file (auth:domolibrary.client.DomoAuth.DomoAuth,\n                              dataset_id:str, upload_id:str,\n                              data_file:Optional[_io.TextIOWrapper]=None, \n                              session:Optional[aiohttp.client.ClientSessio\n                              n]=None, part_id:str=2,\n                              debug_api:bool=False)\n\n\nsource\n\n\nupload_dataset_stage_2_df\n\n upload_dataset_stage_2_df (auth:domolibrary.client.DomoAuth.DomoAuth,\n                            dataset_id:str, upload_id:str,\n                            upload_df:pandas.core.frame.DataFrame, session\n                            :Optional[aiohttp.client.ClientSession]=None,\n                            part_id:str=2, debug_api:bool=False)\n\n\nsource\n\n\nupload_dataset_stage_3\n\n upload_dataset_stage_3 (auth:domolibrary.client.DomoAuth.DomoAuth,\n                         dataset_id:str, upload_id:str, session:Optional[a\n                         iohttp.client.ClientSession]=None,\n                         update_method:str='REPLACE',\n                         partition_tag:str=None, is_index:bool=False,\n                         debug_api:bool=False)\n\ncommit will close the upload session, upload_id. this request defines how the data will be loaded into Adrenaline, update_method has optional flag for indexing dataset.\n\nsource\n\n\nindex_dataset\n\n index_dataset (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n                session:Optional[aiohttp.client.ClientSession]=None,\n                debug_api:bool=False)\n\nmanually index a dataset\n\nsource\n\n\nindex_status\n\n index_status (auth:domolibrary.client.DomoAuth.DomoAuth, dataset_id:str,\n               index_id:str,\n               session:Optional[aiohttp.client.ClientSession]=None,\n               debug_api:bool=False)\n\nget the completion status of an index\n\n# #| export\n# def generate_list_partitions_body(limit=100, offset=0):\n#     return {\n#         \"paginationFields\": [{\n#             \"fieldName\": \"datecompleted\",\n#             \"sortOrder\": \"DESC\",\n#             \"filterValues\": {\n#                 \"MIN\": None,\n#                 \"MAX\": None\n#             }\n#         }],\n#         \"limit\": 1000,\n#         \"offset\": 0\n#     }\n\n\n# #| export\n# async def list_partitions(full_auth: DomoFullAuth,\n#                           dataset_id: str,\n#                           body: dict = None,\n#                           maximum: int = None,\n#                           loop_until_end: bool = True,\n#                           session: aiohttp.ClientSession = None,\n#                           debug: bool = False):\n#     try:\n\n#         is_close_session = False if session else True\n\n#         if not session:\n#             session = aiohttp.ClientSession()\n\n#         body = body or generate_list_partitions_body()\n\n#         url = f\"https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/list\"\n\n#         offset_params = {\n#             'offset': 'offset',\n#             'limit': 'limit',\n#         }\n\n#         def arr_fn(res) -> list[dict]:\n#             return res.response\n\n#         res = await looper(auth=full_auth,\n#                            method='POST',\n#                            url=url,\n#                            arr_fn=arr_fn,\n#                            body=body,\n#                            offset_params_in_body=True,\n#                            offset_params=offset_params,\n#                            loop_until_end=True,\n#                            session=session,\n#                            debug=debug)\n\n#         if isinstance(res, list):\n#             return ResponseGetData(status=200,\n#                                    response=res,\n#                                    is_success=True)\n#         else:\n#             return ResponseGetData(status=400,\n#                                    response=None,\n#                                    is_success=False)\n\n#     finally:\n#         if is_close_session:\n#             await session.close()\n\n# # Delete partition has 3 stages\n# # Stage 1. This marks the data version associated with the partition tag as deleted.  It does not delete the partition tag or remove the association between the partition tag and data version.  There should be no need to upload an empty file – step #3 will remove the data from Adrenaline.\n\n\n# #| export\n# async def delete_partition_stage_1(full_auth: DomoFullAuth,\n#                                    dataset_id: str,\n#                                    dataset_partition_id: str,\n#                                    session: aiohttp.ClientSession = None,\n#                                    debug: bool = False):\n\n#     #url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}'\n#     # update on 9/9/2022 based on the conversation with Greg Swensen\n#     url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/tag/{dataset_partition_id}/data'\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )\n# # Stage 2. This will remove the partition association so that it doesn’t show up in the list call.  Technically, this is not required as a partition against a deleted data version will not count against the 400 partition limit, but as the current partitions api doesn’t make that clear, cleaning these up will make it much easier for you to manage.\n\n\n# #| export\n# async def delete_partition_stage_2(full_auth: DomoFullAuth,\n#                                    dataset_id: str,\n#                                    dataset_partition_id: str,\n#                                    session: aiohttp.ClientSession = None,\n#                                    debug: bool = False):\n\n#     url = f'https://{full_auth.domo_instance}.domo.com/api/query/v1/datasources/{dataset_id}/partition/{dataset_partition_id}'\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )\n\n\n# #| export\n# async def delete(full_auth: DomoFullAuth,\n#                  dataset_id: str, session: aiohttp.ClientSession = None, debug: bool = False):\n#     url = f\"https://{full_auth.domo_instance}.domo.com/api/data/v3/datasources/{dataset_id}?deleteMethod=hard\"\n\n#     return await get_data(\n#         auth=full_auth,\n#         method=\"DELETE\",\n#         url=url,\n#         session=session,\n#         debug=debug\n#     )"
  },
  {
    "objectID": "routes/activity_log.html",
    "href": "routes/activity_log.html",
    "title": "Activity Log Routes",
    "section": "",
    "text": "source\n\nget_activity_log_object_types\n\n get_activity_log_object_types (auth:domolibrary.client.DomoAuth.DomoAuth)\n\nretrieves a list of valid objectTypes that can be used to search the activity_log API\n\nsample implementation of get_activity_log_object_types\n\nimport os\nimport pandas as pd\n\ntry:\n    token_auth = dmda.DomoTokenAuth(\n        domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n        domo_instance=\"domo-dojo\",\n    )\n\n    al_objecttype_res = await get_activity_log_object_types(auth=token_auth)\n\n    print(pd.DataFrame(al_objecttype_res.response))\n\n    # use to update `ActivityLog_ObjectType` enum\n    # [ f\"{objecttype.get('translation').upper().replace(' ', '_')} = '{objecttype.get('type')}'\" for objecttype in  al_objecttype_res.response]\n\nexcept Exception as e:\n    print(e)\n\n                  type         translation\n0         ACCESS_TOKEN        Access token\n1              ACCOUNT             Account\n2         ACTIVITY_LOG        Activity log\n3                ALERT               Alert\n4                  APP                 App\n..                 ...                 ...\n56                VIEW                View\n57        VIRTUAL_USER        Virtual user\n58     Workbench_AGENT     Workbench agent\n59       Workbench_JOB       Workbench job\n60  Workbench_SCHEDULE  Workbench schedule\n\n[61 rows x 2 columns]\n\n\n\nsource\n\n\n\nsearch_activity_log\n\n search_activity_log (auth:domolibrary.client.DomoAuth.DomoAuth,\n                      start_time:int, end_time:int, maximum:int,\n                      object_type:str=None,\n                      session:aiohttp.client.ClientSession=None,\n                      debug_api:bool=False, debug_loop:bool=False)\n\nloops over activity log api to retrieve audit logs\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\npage_res = await search_activity_log(\n    object_type= 'PAGE',\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    auth=token_auth,\n    maximum=16,\n    debug_loop=False,\n)\n\npd.DataFrame(page_res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      objectId\n      objectName\n    \n  \n  \n    \n      0\n      -100000\n      Overview\n    \n    \n      1\n      -100001\n      Alerts\n    \n    \n      2\n      -100002\n      Shared\n    \n    \n      3\n      -100003\n      Favorites\n    \n    \n      4\n      -100012\n      CEO\n    \n  \n\n\n\n\n\nsample implementation of search_activity_log\n\nimport os\nimport pandas as pd\nimport datetime as dt\n\nimport domolibrary.utils.convert as convert\n\nend_datetime = dt.datetime.today()\nstart_datetime = end_datetime - dt.timedelta(days=100)\n\ntoken_auth = dmda.DomoTokenAuth(\n    domo_access_token=os.environ[\"DOMO_DOJO_ACCESS_TOKEN\"],\n    domo_instance=\"domo-dojo\",\n)\n\nactivity_log_res = await search_activity_log(\n    object_type= 'ACTIVITY_LOG',\n    start_time=convert.convert_datetime_to_epoch_millisecond(start_datetime),\n    end_time=convert.convert_datetime_to_epoch_millisecond(end_datetime),\n    auth=token_auth,\n    maximum=10,\n    debug_loop=False,\n    debug_api=False,\n)\n\npd.DataFrame(activity_log_res.response[0:5])\n\n\n\n\n\n  \n    \n      \n      userName\n      userId\n      userType\n      actorName\n      actorId\n      actionType\n      objectName\n      objectId\n      objectType\n      additionalComment\n      time\n      eventText\n      clientId\n    \n  \n  \n    \n      0\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990172331\n      Updated DataSet\n      None\n    \n    \n      1\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990172331\n      Updated DataSet\n      None\n    \n    \n      2\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      UPDATED\n      domo_kbs\n      04c1574e-c8be-4721-9846-c6ffa491144b\n      DATA_SOURCE\n      Jae Wilson updated DataSet domo_kbs.\n      1673990169279\n      Updated DataSet\n      None\n    \n    \n      3\n      test@test.com\n      test@test.com\n      USER\n      \n      0\n      FAILED_LOGIN\n      \n      \n      \n      test@test.com failed logging in. Logged in fro...\n      1673990168450\n      Failed login\n      None\n    \n    \n      4\n      Jae Wilson\n      1893952720\n      USER\n      \n      0\n      FAILED_LOGIN\n      \n      \n      \n      Jae Wilson failed logging in. Logged in from I...\n      1673990168159\n      Failed login\n      None"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "",
    "text": "domolibrary is a Python package that provides a OOP (class-based) and a functional approach to interacting with Domo’s API framework.\nAll accessed APIs are documented under DataCrew’s Domo Documentation page.\nThis library was created by DataCrew contributor Jae Wilson."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "Install",
    "text": "Install\nThe DataCrew team is hard at work expanding the list of available classes and routes. We have a ton of work completed, it’s just a matter of migrating and documenting the code into this library.\npip install domo_library"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "domolibrary: a powerful pydomo alternative",
    "section": "How to use",
    "text": "How to use\n\nAuthentication\nFor each task, consider the appropriate DomoAuth mechanism. In most cases DomoFullAuth or DomoTokenAuth will be appropriate as this library predominately accesses private APIs.\nAny Public routes or methods will be labeled appropriately in which case you should use DomoDeveloperAuth. Public routes are APIs enumerated and documented under Developer.Domo.com.\nTypically each project will begin with configuring an auth object. If you are accessing multiple Domo instances, you’ll probably need multiple auth objects.\n\n# configure an auth method\nimport os\nimport domolibrary.client.DomoAuth as dmda\n\ntoken_auth = dmda.DomoTokenAuth( domo_instance = 'domo-dojoo', domo_access_token = os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n\n\nOption 1: class based programming\nIn this project domo entities, DomoActivityLog, DomoDataset are all prefixed ‘Domo’ and can be found in the classes folder. Each class method will call one or more routes. Each route will interact with one and only one API.\nAlthough most methods will be standard methods that will be called after creating an instance of the class, some methods will be classmethods which return an instance of the class.\nIn the example below, DomoDataset.get_from_id is a classmethod.\nNote: DomoLibrary uses the asynchronous aiohttp requests library to offer users the ability to write concurrently executing code.\n\nimport domolibrary.classes.DomoDataset as dmds\n\n# this is a class method\ndomo_ds = await dmds.DomoDataset.get_from_id(auth = token_auth, dataset_id = os.environ['DOJO_DATASET_ID'])\ndomo_ds\n\nDomoDataset(id='04c1574e-c8be-4721-9846-c6ffa491144b', display_type='domo-jupyterdata', data_provider_type='domo-jupyterdata', name='domo_kbs', description=None, row_count=1185, column_count=7, stream_id=825, owner=DictDot(id='1893952720', name='Jae Wilson', type='USER', group=False), formula=DictDot(), schema=DomoDataset_Schema(dataset=..., columns=[]))\n\n\nOnce instantiated, you can call methods to interact with that object. You typically won’t have to pass auth creds again because they are saved to the object.\nIn the example below we are retrieving the DomoDataset_Schema which consists of subclass DomoDataset_Schema_Column using the DomoDataset_Schema.get method.\nWe take the approach of where possible converting dictionaries from Domo APIs into classes because it provides greater predictability when users are creating integrations between platforms (ex. Domo to Trello).\n\nawait domo_ds.schema.get()\n\n[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'),\n DomoDataset_Schema_Column(name='url', id='url', type='STRING'),\n DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'),\n DomoDataset_Schema_Column(name='article', id='article', type='STRING'),\n DomoDataset_Schema_Column(name='views', id='views', type='LONG'),\n DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'),\n DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')]\n\n\nTypically all information about an entity is saved in the object\n\ndomo_ds.__dict__\n\n{'auth': DomoTokenAuth(domo_instance='domo-dojoo', token_name='token_auth', url_manual_login='https://domo-dojoo.domo.com/auth/index?domoManualLogin=true'),\n 'id': '04c1574e-c8be-4721-9846-c6ffa491144b',\n 'display_type': 'domo-jupyterdata',\n 'data_provider_type': 'domo-jupyterdata',\n 'name': 'domo_kbs',\n 'description': None,\n 'row_count': 1185,\n 'column_count': 7,\n 'stream_id': 825,\n 'owner': namespace(id='1893952720',\n           name='Jae Wilson',\n           type='USER',\n           group=False),\n 'formula': namespace(),\n 'schema': DomoDataset_Schema(dataset=DomoDataset(id='04c1574e-c8be-4721-9846-c6ffa491144b', display_type='domo-jupyterdata', data_provider_type='domo-jupyterdata', name='domo_kbs', description=None, row_count=1185, column_count=7, stream_id=825, owner=DictDot(id='1893952720', name='Jae Wilson', type='USER', group=False), formula=DictDot(), schema=...), columns=[DomoDataset_Schema_Column(name='objectID', id='objectID', type='STRING'), DomoDataset_Schema_Column(name='url', id='url', type='STRING'), DomoDataset_Schema_Column(name='Title', id='Title', type='STRING'), DomoDataset_Schema_Column(name='article', id='article', type='STRING'), DomoDataset_Schema_Column(name='views', id='views', type='LONG'), DomoDataset_Schema_Column(name='created_dt', id='created_dt', type='DATETIME'), DomoDataset_Schema_Column(name='published_dt', id='published_dt', type='DATETIME')])}\n\n\n\n\nOption 2 functional programming\nAlthough classes add a pretty wrapper for interacting with Domo APIs, users can opt to interact directly with APIs by way of routes.\nAll route functions will exclusively call one API and will always return a ResponseGetData object OR raise an Exception if appropriate.\nFor example we can implement similar functionality as the Option 1 example by calling the get_dataset_by_id function.\n\nimport domolibrary.routes.dataset as dataset_routes\n\nds_res = await dataset_routes.get_dataset_by_id( auth = token_auth, dataset_id = os.environ['DOJO_DATASET_ID'])\nds_res\n\nResponseGetData(status=200, response={'id': '04c1574e-c8be-4721-9846-c6ffa491144b', 'displayType': 'domo-jupyterdata', 'dataProviderType': 'domo-jupyterdata', 'type': 'Jupyter', 'name': 'domo_kbs', 'owner': {'id': '1893952720', 'name': 'Jae Wilson', 'type': 'USER', 'group': False}, 'status': 'SUCCESS', 'created': 1668379680000, 'lastTouched': 1668385822000, 'lastUpdated': 1668385822045, 'rowCount': 1185, 'columnCount': 7, 'cardInfo': {'cardCount': 0, 'cardViewCount': 0}, 'properties': {'formulas': {'formulas': {}}}, 'state': 'SUCCESS', 'validConfiguration': True, 'validAccount': True, 'streamId': 825, 'transportType': 'API', 'adc': False, 'adcExternal': False, 'cloudId': 'domo', 'cloudName': 'Domo', 'permissions': 'READ_WRITE_DELETE_SHARE_ADMIN', 'hidden': False, 'tags': '[\"developer_documentation\",\"Jan-11-2023 12:50\",\"hackercore\"]', 'scheduleActive': True, 'cryoStatus': 'ADRENALINE'}, is_success=True)\n\n\nResponseGetData will always include a boolean is_success, the API status, and raw API response.\nTypically the route methods will not alter the response unless the API does not include a descriptive response (ex, routes.dataset.set_dataset_tags does not return a response so we artificially alter the response in the function.)\n\n[(prop, type(getattr(ds_res , prop))) for prop in dir(ds_res) if not prop.startswith('_')]\n\n[('auth', domolibrary.client.DomoAuth.DomoTokenAuth),\n ('is_success', bool),\n ('response', dict),\n ('set_response', method),\n ('status', int)]\n\n\n\nds_res.response\n\n{'id': '04c1574e-c8be-4721-9846-c6ffa491144b',\n 'displayType': 'domo-jupyterdata',\n 'dataProviderType': 'domo-jupyterdata',\n 'type': 'Jupyter',\n 'name': 'domo_kbs',\n 'owner': {'id': '1893952720',\n  'name': 'Jae Wilson',\n  'type': 'USER',\n  'group': False},\n 'status': 'SUCCESS',\n 'created': 1668379680000,\n 'lastTouched': 1668385822000,\n 'lastUpdated': 1668385822045,\n 'rowCount': 1185,\n 'columnCount': 7,\n 'cardInfo': {'cardCount': 0, 'cardViewCount': 0},\n 'properties': {'formulas': {'formulas': {}}},\n 'state': 'SUCCESS',\n 'validConfiguration': True,\n 'validAccount': True,\n 'streamId': 825,\n 'transportType': 'API',\n 'adc': False,\n 'adcExternal': False,\n 'cloudId': 'domo',\n 'cloudName': 'Domo',\n 'permissions': 'READ_WRITE_DELETE_SHARE_ADMIN',\n 'hidden': False,\n 'tags': '[\"developer_documentation\",\"Jan-11-2023 12:50\",\"hackercore\"]',\n 'scheduleActive': True,\n 'cryoStatus': 'ADRENALINE'}\n\n\n\n\nAccess Paginated APIs using the Looper\nA hidden advantage of using the DomoLibrary is that paginated API requests are baked into the route’s definition.\nConsider query_dataset_private from the routes.dataset.\nInside this function we are using looper from client.get_data to paginate over the API response."
  },
  {
    "objectID": "utils/utils.convert.html",
    "href": "utils/utils.convert.html",
    "title": "Conversion utility functions",
    "section": "",
    "text": "source\n\nconvert_epoch_millisecond_to_datetime\n\n convert_epoch_millisecond_to_datetime (epoch:int)\n\nconvert Epoch time with miliseconds to Date time\n\nsource\n\n\nconvert_datetime_to_epoch_millisecond\n\n convert_datetime_to_epoch_millisecond (datetime:datetime.datetime)\n\nconvert DateTime to Epoch time with Miliseconds\n\nimport time\nimport datetime as dt \n\ncur_time = int(time.time()*1000)\n\ncur_datetime =  convert_epoch_millisecond_to_datetime(cur_time)\nprint(cur_datetime)\n\ntest_time = convert_datetime_to_epoch_millisecond(cur_datetime)\nprint(test_time)\n\nfctest.test_eq(test_time, cur_time)\n\n2023-01-17 21:16:14.031000\n1673990174031\n\n\n\nsource\n\n\nconvert_snake_to_pascal\n\n convert_snake_to_pascal (str)\n\nconverts ‘snake_case_str’ to ‘snakeCaseStr’\n\nconvert_str = 'test_snake_case'\n\nconvert_snake_to_pascal(convert_str)\n\n'testSnakeCase'"
  },
  {
    "objectID": "utils/dictdot.html",
    "href": "utils/dictdot.html",
    "title": "DictDot",
    "section": "",
    "text": "source\n\nDictDot\n\n DictDot (dictionary:dict, **kwargs)\n\na utility class that converts json into an object that supports data retrieval with dot notation\n\n\n\n\nType\nDetails\n\n\n\n\ndictionary\ndict\ndictionary to convert\n\n\nkwargs\n\n\n\n\n\n\nsample implementation of DictDot\n\nfoo = { \"name\": \"my object\", \"description\" : \"please convert me\", \"type\": \"a good old fashioned dictionary\"}\n\ndd = DictDot(foo)\n\nprint(dd)\n\ndd.type\n\nDictDot(name='my object', description='please convert me', type='a good old fashioned dictionary')\n\n\n'a good old fashioned dictionary'"
  },
  {
    "objectID": "integrations/domojupyter.html#get-domains-with-global-config-deprecated",
    "href": "integrations/domojupyter.html#get-domains-with-global-config-deprecated",
    "title": "DomoJupyter (GetInstanceCredentials)",
    "section": "Get Domains with Global Config (DEPRECATED)",
    "text": "Get Domains with Global Config (DEPRECATED)\nUse this method to configure a dataset that retrieves a list of domains from a config instance (using config credentials) and then includes a global_auth or global_exception_auth for each retrieved domo_instance which will be used to configure the instance.\nTheoretically, the global user should be an Admin alreado Domo’ed to the instance\nThe Config Dataset must return columns domo_instance and config_exception_pw\nNOTE: this method works as designed, but get_domains_with_instance_auth method is more flexible as it supports more variations by using an Enum class for matching.\n\n\nGetInstanceConfig.get_domains_with_global_config_auth\n\n GetInstanceConfig.get_domains_with_global_config_auth\n                                                        (config_dataset_id\n                                                        :str, config_auth:\n                                                        domolibrary.client\n                                                        .DomoAuth.DomoAuth\n                                                        , global_auth:domo\n                                                        library.client.Dom\n                                                        oAuth.DomoAuth, gl\n                                                        obal_exception_aut\n                                                        h:domolibrary.clie\n                                                        nt.DomoAuth.DomoAu\n                                                        th, config_sql:str\n                                                        ='select domain as\n                                                        domo_instance, con\n                                                        fig_exception_pw\n                                                        from table', debug\n                                                        _api:bool=False, d\n                                                        ebug_log:bool=Fals\n                                                        e, debug_prn:bool=\n                                                        False, logger:domo\n                                                        library.client.Log\n                                                        ger.Logger=None)\n\n\n\n\nGetDomains_Query_Exception_PW_Col_Error\n\n GetDomains_Query_Exception_PW_Col_Error (sql:str=None,\n                                          domo_instance:str=None,\n                                          message:str=None)\n\nraise if SQL query fails to return column named ‘config_exception_pw’\n\nsample implementation of get_domains_with_global_config_auth\n\nimport os\n\nconfig_auth = dmda.DomoTokenAuth(\n    domo_instance='domo-dojo', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nglobal_auth = dmda.DomoTokenAuth(\n    domo_instance='domo-global', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\nglobal_exception_auth = dmda.DomoTokenAuth(\n    domo_instance='domo-global', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n\nlogger = lc.Logger(app_name='test_retrieve_company')\n\nres = await GetInstanceConfig.get_domains_with_global_config_auth(config_auth=config_auth,\n                                                            config_dataset_id='8d2a8055-7918-4039-b67d-361647e96ea8',\n                                                                  config_sql='SELECT domain as domo_instance, 1 as config_exception_pw  from Table',\n                               debug_prn=True,\n                               debug_log=False,\n                               debug_api=False,\n                               logger=logger,\n                               global_auth = global_auth,\n                                                                  global_exception_auth=global_exception_auth\n                               )\n\npd.DataFrame(res)\n# pd.DataFrame(logger.logs)\n\n⚙️ START - Retrieving company list \nhttps://domo-dojo.domo.com/datasources/8d2a8055-7918-4039-b67d-361647e96ea8/details/overview using \nSELECT domain as domo_instance, 1 as config_exception_pw  from Table\n\n⚙️ SUCCESS 🎉 Retrieved company list \nThere are 1 companies to update\n\n\n\n\n\n\n  \n    \n      \n      domo_instance\n      config_exception_pw\n      is_valid\n      instance_auth\n    \n  \n  \n    \n      0\n      domo-dojo\n      1\n      1.0\n      DomoTokenAuth(domo_instance='domo-dojo', token..."
  },
  {
    "objectID": "integrations/domojupyter.html#get-domains-with-instance-config",
    "href": "integrations/domojupyter.html#get-domains-with-instance-config",
    "title": "DomoJupyter (GetInstanceCredentials)",
    "section": "Get Domains with Instance Config",
    "text": "Get Domains with Instance Config\nUse this method to configure a dataset that retrieves a list of domains from a config instance (using config credentials). Pass an auth_enum object to enumerate different authenticaiton variations to expect in the result dataset (see example).\nTheoretically, each of the enumerated auth variations should already exist in the instance.\nThe Config Dataset must return columns domo_instance and auth_match_col\n\n\nGetInstanceConfig.get_domains_with_instance_auth\n\n GetInstanceConfig.get_domains_with_instance_auth (config_dataset_id:str,\n                                                   config_auth:domolibrary\n                                                   .client.DomoAuth.DomoAu\n                                                   th, default_auth:domoli\n                                                   brary.client.DomoAuth.D\n                                                   omoAuth,\n                                                   auth_enum:enum.Enum,\n                                                   config_sql:str=\"select\n                                                   domain as domo_instance\n                                                   ,concat(config_useprod,\n                                                   '-', project) as\n                                                   auth_match_col from\n                                                   table\",\n                                                   debug_api:bool=False,\n                                                   debug_log:bool=False,\n                                                   debug_prn:bool=False, l\n                                                   ogger:Optional[domolibr\n                                                   ary.client.Logger.Logge\n                                                   r]=None)\n\n\n\n\nGetDomains_Query_AuthMatch_Error\n\n GetDomains_Query_AuthMatch_Error (sql:str=None, domo_instance:str=None,\n                                   message:str=None)\n\nraise if SQL query fails to return column named ‘auth_match_col’\n\nsample implementation of get_domains_with_instance_auth\n\nimport os\n\nconfig_auth = dmda.DomoTokenAuth(\n    domo_instance='domo-dojo', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\ndefault_auth = dmda.DomoTokenAuth(\n    domo_instance='default', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n\nclass AuthEnum(Enum):\n    test_1 = dmda.DomoTokenAuth(\n        domo_instance='test_1', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n    test_0 = dmda.DomoTokenAuth(\n        domo_instance='test_0', domo_access_token=os.environ['DOMO_DOJO_ACCESS_TOKEN'])\n\n\nlogger = lc.Logger(app_name='test_retrieve_company')\n\nres = await GetInstanceConfig.get_domains_with_instance_auth(config_auth=config_auth,\n                                                             config_dataset_id='8d2a8055-7918-4039-b67d-361647e96ea8',\n                                                             config_sql=\"SELECT domain as domo_instance, 'test_1' as auth_match_col from Table\",\n                                                             debug_prn=True,\n                                                             debug_log=False,\n                                                             debug_api=False,\n                                                             logger=logger,\n                                                             default_auth = default_auth,\n                                                             auth_enum=AuthEnum\n                                                             )\n\npd.DataFrame(res)\n# pd.DataFrame(logger.logs)\n\n⚙️ START - Retrieving company list \nhttps://domo-dojo.domo.com/datasources/8d2a8055-7918-4039-b67d-361647e96ea8/details/overview using \nSELECT domain as domo_instance, 'test_1' as auth_match_col from Table\n\n⚙️ SUCCESS 🎉 Retrieved company list \nThere are 1 companies to update\n\n\n\n\n\n\n  \n    \n      \n      domo_instance\n      auth_match_col\n      is_valid\n      instance_auth\n    \n  \n  \n    \n      0\n      domo-dojo\n      test_1\n      1.0\n      DomoTokenAuth(domo_instance='domo-dojo', token..."
  }
]